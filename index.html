<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>murmur — Cameron Barnett</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: "SF Mono", "Consolas", monospace;
      font-weight: 200;
      -webkit-font-smoothing: antialiased;
      background: #0a0a0a;
      color: #ffffff;
      min-height: 100vh;
      margin: 0;
      padding: 3rem 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .byline {
      font-size: 0.85rem;
      font-weight: 200;
      color: #9aa;
      text-shadow: 0 0 12px rgba(100, 180, 255, 0.4);
      margin-bottom: 2rem;
    }
    .poem {
      max-width: 420px;
      font-size: 1rem;
      font-weight: 200;
      line-height: 1.8;
      white-space: pre-wrap;
      word-break: break-word;
      color: #ffffff;
    }
    .poem .stanza { margin-bottom: 1.5rem; }
    .poem .stanza-num {
      font-variant-numeric: tabular-nums;
      margin-bottom: 0.25rem;
    }
    .page-break {
      margin: 2.5rem 0;
      text-align: center;
      color: #444;
      font-size: 0.75rem;
    }
    .roll {
      display: inline-block;
      font-variant-numeric: tabular-nums;
      min-width: 1ch;
    }
    .roll.done { animation: none; }
    .symbol-roll {
      display: inline-block;
      min-width: 1ch;
      color: #7dd3fc;
      text-shadow: 0 0 8px rgba(125, 211, 252, 0.6);
    }
    .unstable {
      display: inline-block;
      animation: unstable 0.32s steps(4, jump-end) infinite;
      color: #f472b6;
      text-shadow: 0 0 10px rgba(244, 114, 182, 0.7);
    }
    .unstable:nth-child(6n) { animation-delay: 0s; }
    .unstable:nth-child(6n+1) { animation-delay: -0.04s; }
    .unstable:nth-child(6n+2) { animation-delay: -0.11s; }
    .unstable:nth-child(6n+3) { animation-delay: -0.19s; }
    .unstable:nth-child(6n+4) { animation-delay: -0.06s; }
    .unstable:nth-child(6n+5) { animation-delay: -0.15s; }
    @keyframes unstable {
      0% { transform: translate(0, 0); opacity: 1; color: #f472b6; text-shadow: 0 0 10px rgba(244, 114, 182, 0.7); }
      25% { transform: translate(2px, 0); opacity: 0.5; color: #ec4899; text-shadow: 0 0 16px rgba(236, 72, 153, 0.9); }
      50% { transform: translate(-1px, 0); opacity: 0.9; color: #f9a8d4; text-shadow: 0 0 12px rgba(249, 168, 212, 0.8); }
      75% { transform: translate(-2px, 0); opacity: 0.4; color: #db2777; text-shadow: 0 0 20px rgba(219, 39, 119, 0.8); }
      100% { transform: translate(0, 0); opacity: 1; color: #f472b6; text-shadow: 0 0 10px rgba(244, 114, 182, 0.7); }
    }
    .input-section {
      width: 100%;
      max-width: 420px;
      margin-bottom: 2rem;
    }
    .input-section label {
      display: block;
      font-size: 0.8rem;
      font-weight: 200;
      color: #8b9;
      margin-bottom: 0.5rem;
    }
    .input-section input,
    .input-section textarea {
      width: 100%;
      font-weight: 200;
      background: #0a0a0a;
      border: 1px solid #2a3a4a;
      color: #ffffff;
      font-family: inherit;
      font-size: 14px;
      padding: 0.5rem 0.75rem;
    }
    .input-section input { margin-bottom: 0.75rem; }
    .input-section textarea {
      min-height: 100px;
      resize: vertical;
    }
    .input-section input:focus,
    .input-section textarea:focus {
      outline: none;
      border-color: #58a6ff;
      box-shadow: 0 0 0 1px #58a6ff, 0 0 12px rgba(88, 166, 255, 0.35);
    }
    .input-section input[type="file"] {
      padding: 0.25rem 0;
      font-size: 12px;
    }
    .ocr-status {
      font-size: 0.75rem;
      font-weight: 200;
      color: #6b7;
      margin-top: 0.5rem;
      min-height: 1.2em;
    }
    .ocr-status.working { color: #7dd3fc; text-shadow: 0 0 8px rgba(125, 211, 252, 0.5); }
    .ocr-status.error { color: #f87171; text-shadow: 0 0 8px rgba(248, 113, 113, 0.5); }
  </style>
</head>
<body>
  <div class="input-section">
    <label for="byline-input">Title / author (optional)</label>
    <input type="text" id="byline-input" placeholder="e.g. murmur — Cameron Barnett">
    <label for="poem-input">Your poem (optional — leave blank for default)</label>
    <textarea id="poem-input" placeholder="Paste or type your own poem here..."></textarea>
    <label for="file-input">Or upload an image or PDF</label>
    <input type="file" id="file-input" accept="image/*,.pdf">
    <p class="ocr-status" id="ocr-status"></p>
  </div>
  <p class="byline" id="byline">murmur — Cameron Barnett</p>
  <main class="poem" id="poem"></main>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
  </script>
  <script>
    const mathWords = {
      'plus': '+',
      'minus': '−',
      'times': '×',
      'divided by': '÷',
      'equals': '=',
      'squared': '²',
      'cubed': '³',
      'less than': '<',
      'greater than': '>',
      'less than or equal to': '≤',
      'greater than or equal to': '≥',
      'not equal to': '≠',
      'approximately': '≈',
      'infinity': '∞',
      'pi': 'π',
      'square root': '√',
      'power': '^'
    };

    const digits = '01';
    const rollToChar = 'I';
    const rollIntervalMs = 420;
    const rollStepsBeforeI = 12;
    const digitHoldMs = 420;
    const SYMBOL_CYCLE = ['+', '−', '×', '÷', '=', '∞', '√', 'π', '^'];
    const SYMBOL_PHASE_OFFSET_MS = 210;

    function replaceMathWords(text) {
      let out = text;
      const keys = Object.keys(mathWords).sort((a, b) => b.length - a.length);
      for (const key of keys) {
        const re = new RegExp(key.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
        out = out.replace(re, mathWords[key]);
      }
      return out;
    }

    function isDigit(c) {
      return c === '0' || c === '1';
    }

    function isMathSymbol(c) {
      return SYMBOL_CYCLE.indexOf(c) !== -1 || '²³<>≤≠≈'.indexOf(c) !== -1;
    }

    function isFragmentationChar(c) {
      return c === '•' || c === '·' || c === '~' || c === '_';
    }

    function rollDigitToI(el, fromChar, delay) {
      el.textContent = fromChar;
      el.classList.remove('done');
      const startIdx = digits.indexOf(fromChar);
      const binaryRun = (startIdx >= 0 ? digits.slice(startIdx) : '') + digits.repeat(Math.ceil(rollStepsBeforeI / 2)).slice(0, rollStepsBeforeI);
      const sequence = binaryRun + rollToChar;
      let step = 0;
      setTimeout(() => {
        const intervalId = setInterval(() => {
          step++;
          el.textContent = sequence[step] ?? rollToChar;
          if (el.textContent === rollToChar) {
            el.classList.add('done');
            clearInterval(intervalId);
          }
        }, rollIntervalMs);
      }, digitHoldMs);
    }

    function startSymbolRoll(el, symbol) {
      const cycle = SYMBOL_CYCLE;
      let idx = cycle.indexOf(symbol);
      if (idx === -1) idx = 0;
      el.textContent = cycle[idx];
      setTimeout(() => {
        setInterval(() => {
          idx = (idx + 1) % cycle.length;
          el.textContent = cycle[idx];
        }, rollIntervalMs);
      }, SYMBOL_PHASE_OFFSET_MS);
    }

    const DEFAULT_BYLINE = 'murmur — Cameron Barnett';
    const DEFAULT_POEM =
`1.
I · · oun. · --_ r
n.e er lt • hole,
I onl felt .m . •
di i ·ions.
•
•
If the bo. • were a senten·ce,
•. ould we place . the heart
behind an ·ampersand
or between brackets?
0.
_ _en
was younger
learned that a rainbow
• s ju t a trick, a kiss
I was younger,
• st pped giving
• 1 • e · for fear
of being tric ·ed.
l
I
•
•
•
•
•
•
•
•
•
n
2
•
•
•
•
w
•
•
•
•
,of light and water When
1.
Th b~g ha ,·g • , aft r· all,
JU 't an . h · h y, , n
th o y 1 · h all • · _ 1 •

——— 0 ———

•
•
•
•
0.
Ir' no wond1er
I find m· . best
re.fl1e ction tow,ar,d
the margins •
of most things.
1.
•
If the body is just a. tri,ck,
•
a coll,ective· norhingn,ess,
qu.ainc an,d •c.oded, all one.s
and z,eros, then it's no wonder
I n.ever felt whole
until yo,u kis.sed m1e.
' •
•
•
•
•
•
•
•
•
•
•
•
• •`;

    function applyToElement(el, raw) {
      const text = raw ?? el.textContent;
      const withSymbols = replaceMathWords(text);
      el.innerHTML = '';
      for (const char of withSymbols) {
        if (isDigit(char)) {
          const span = document.createElement('span');
          span.className = 'roll';
          span.textContent = char;
          el.appendChild(span);
        } else if (isMathSymbol(char)) {
          const span = document.createElement('span');
          span.className = 'symbol-roll';
          el.appendChild(span);
          startSymbolRoll(span, char);
        } else if (isFragmentationChar(char)) {
          const span = document.createElement('span');
          span.className = 'unstable';
          span.textContent = char;
          el.appendChild(span);
        } else {
          el.appendChild(document.createTextNode(char));
        }
      }
      el.querySelectorAll('.roll').forEach((rollEl, i) => {
        setTimeout(() => rollDigitToI(rollEl, rollEl.textContent, 0), i * 120);
      });
    }

    function simulateBadOcr(text) {
      const frag = ['•', '·', '~', '_'];
      let out = '';
      const lines = text.split(/\n/);
      for (let li = 0; li < lines.length; li++) {
        const line = lines[li];
        for (let i = 0; i < line.length; i++) {
          const c = line[i];
          const n = (li * 997 + i * 31 + c.charCodeAt(0)) % 100;
          if (n < 5) {
            out += frag[(li + i) % frag.length];
          } else if (n < 9 && i > 0 && i < line.length - 1 && /\w/.test(c)) {
            out += c + '·';
          } else if (n < 14 && /\w/.test(c)) {
            if (c === 'o' || c === 'O') out += n % 2 ? '0' : c;
            else if (c === 'l' || c === 'i' || c === 'I') out += n % 2 ? '1' : c;
            else out += c;
          } else {
            out += c;
          }
        }
        if (li < lines.length - 1) out += '\n';
      }
      return out;
    }

    function updateDisplay() {
      const bylineRaw = document.getElementById('byline-input').value.trim();
      const poemRaw = document.getElementById('poem-input').value;
      const bylineEl = document.getElementById('byline');
      const poemEl = document.getElementById('poem');
      bylineEl.textContent = bylineRaw || DEFAULT_BYLINE;
      const isUserPoem = poemRaw && poemRaw !== DEFAULT_POEM;
      const poemToShow = isUserPoem ? simulateBadOcr(poemRaw) : (poemRaw || DEFAULT_POEM);
      poemEl.textContent = poemToShow;
      applyToElement(bylineEl);
      applyToElement(poemEl);
    }

    document.getElementById('byline-input').addEventListener('input', () => {
      clearTimeout(window._poemTimer);
      window._poemTimer = setTimeout(updateDisplay, 200);
    });
    document.getElementById('poem-input').addEventListener('input', () => {
      clearTimeout(window._poemTimer);
      window._poemTimer = setTimeout(updateDisplay, 200);
    });

    function degradeOCRText(ocrText) {
      const frag = ['•', '·', '~', '_'];
      let out = '';
      const lines = ocrText.split(/\n/);
      for (let li = 0; li < lines.length; li++) {
        const line = lines[li];
        for (let i = 0; i < line.length; i++) {
          const c = line[i];
          const r = Math.random();
          if (r < 0.045) {
            out += frag[Math.floor(Math.random() * frag.length)];
          } else if (r < 0.07 && i > 0 && i < line.length - 1 && /\w/.test(c)) {
            out += c + '·';
          } else if (r < 0.095 && /\w/.test(c)) {
            if (c === 'o' || c === 'O') out += Math.random() < 0.5 ? '0' : c;
            else if (c === 'l' || c === 'i' || c === 'I') out += Math.random() < 0.5 ? '1' : c;
            else out += c;
          } else {
            out += c;
          }
        }
        if (li < lines.length - 1) out += '\n';
      }
      return out;
    }

    async function pdfPagesToImages(file) {
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      const numPages = pdf.numPages;
      const scale = 2;
      const pageTexts = [];
      for (let n = 1; n <= numPages; n++) {
        const page = await pdf.getPage(n);
        const viewport = page.getViewport({ scale });
        const canvas = document.createElement('canvas');
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        const ctx = canvas.getContext('2d');
        await page.render({ canvasContext: ctx, viewport }).promise;
        const blob = await new Promise((resolve) => canvas.toBlob(resolve, 'image/png'));
        pageTexts.push(blob);
      }
      return pageTexts;
    }

    document.getElementById('file-input').addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      const status = document.getElementById('ocr-status');
      status.textContent = 'Processing…';
      status.className = 'ocr-status working';
      try {
        let text = '';
        if (file.type === 'application/pdf') {
          status.textContent = 'Loading PDF…';
          const pageBlobs = await pdfPagesToImages(file);
          for (let i = 0; i < pageBlobs.length; i++) {
            status.textContent = 'OCR page ' + (i + 1) + ' of ' + pageBlobs.length + '…';
            const { data: { text: pageText } } = await Tesseract.recognize(pageBlobs[i], 'eng', {
              logger: (m) => { if (m.status) status.textContent = 'Page ' + (i + 1) + ': ' + m.status; }
            });
            text += (pageText || '').trim();
            if (i < pageBlobs.length - 1) text += '\n\n——— ' + (i + 1) + ' ———\n\n';
          }
        } else {
          const { data } = await Tesseract.recognize(file, 'eng', {
            logger: (m) => { if (m.status) status.textContent = m.status; }
          });
          text = data.text || '';
        }
        const bad = degradeOCRText(text);
        document.getElementById('poem-input').value = bad;
        document.getElementById('byline-input').value = file.name.replace(/\.[^.]+$/, '') || 'Uploaded';
        updateDisplay();
        status.textContent = 'Done.';
        status.className = 'ocr-status';
      } catch (err) {
        status.textContent = 'Failed: ' + (err.message || 'unknown error');
        status.className = 'ocr-status error';
      }
      e.target.value = '';
    });

    updateDisplay();
  </script>
</body>
</html>
